@startuml Component to Class Mapping

skinparam rectangle {
    BackgroundColor<<component>> #CCE5FF
    BackgroundColor<<class>> #FFF9DB
    BorderColor #1F2A44
}

skinparam note {
    BackgroundColor #F0FFF4
    BorderColor #2E8B57
}

title Component to Class Mapping - Layered Architecture

' ==================== FRONTEND LAYER ====================
rectangle "FRONTEND UI LAYER" {
    rectangle "App Shell Component" <<component>> as APP_COMP
    rectangle "src/App.tsx" <<class>> as APP_CLASS
    APP_COMP -down-> APP_CLASS : implements
    
    rectangle "Screen Components" <<component>> as SCREEN_COMP
    rectangle "LoginScreen.tsx\nDashboardScreen.tsx\nWorkoutLogScreen.tsx\nGoalSettingScreen.tsx\nProfileScreen.tsx" <<class>> as SCREEN_CLASS
    SCREEN_COMP -down-> SCREEN_CLASS : implements
    
    rectangle "HTTP Client Component" <<component>> as API_COMP
    rectangle "src/services/api.ts\n(userApi, workoutApi,\ngoalApi helpers)" <<class>> as API_CLASS
    API_COMP -down-> API_CLASS : implements
}

note right of SCREEN_CLASS
  **Frontend responsibilities**
  • App.tsx orchestrates navigation + auth state.
  • Screen components render UI and call callbacks.
  • api.ts houses fetch helpers that target http://localhost:8081/api/**.
  • React components talk ONLY to api.ts which, in turn, issues HTTP requests.
end note

' ==================== PRESENTATION LAYER ====================
rectangle "PRESENTATION LAYER" {
    rectangle "UserController Component" <<component>> as UC_COMP
    rectangle "UserController.java" <<class>> as UC_CLASS
    UC_COMP -down-> UC_CLASS : implements
    
    rectangle "WorkoutController Component" <<component>> as WC_COMP  
    rectangle "WorkoutController.java" <<class>> as WC_CLASS
    WC_COMP -down-> WC_CLASS : implements
    
    rectangle "GoalController Component" <<component>> as GC_COMP
    rectangle "GoalController.java" <<class>> as GC_CLASS
    GC_COMP -down-> GC_CLASS : implements
}

note right of UC_CLASS
  **Controller Layer Mapping**
  • Controllers expose REST endpoints under /api/**.
  • They accept DTO payloads, validate, and delegate to services only.
  • Source files live in fitness-backend/.../controller/.
end note

' ==================== BUSINESS LOGIC LAYER ====================
rectangle "APPLICATION/SERVICE LAYER" {
    rectangle "UserService Component" <<component>> as US_COMP
    rectangle "UserService.java (interface)\nUserServiceImpl.java" <<class>> as US_CLASS
    US_COMP -down-> US_CLASS : implements
    
    rectangle "WorkoutService Component" <<component>> as WS_COMP
    rectangle "WorkoutService.java (interface)\nWorkoutServiceImpl.java" <<class>> as WS_CLASS
    WS_COMP -down-> WS_CLASS : implements
    
    rectangle "GoalService Component" <<component>> as GS_COMP
    rectangle "GoalService.java (interface)\nGoalServiceImpl.java" <<class>> as GS_CLASS
    GS_COMP -down-> GS_CLASS : implements
}

note right of US_CLASS
  **Service responsibilities**
  • Encapsulate business logic (goal uniqueness, progress updates).
  • Use constructor injection for repositories + mappers.
  • Annotated with @Service and @Transactional where needed.
end note

' ==================== DATA LAYER ====================
rectangle "DATA LAYER (Mapping + Persistence)" {
    rectangle "Mapper Components" <<component>> as MAPPER_COMP
    rectangle "UserMapper.java\nWorkoutMapper.java\nGoalMapper.java\nExerciseMapper.java" <<class>> as MAPPER_CLASS
    MAPPER_COMP -down-> MAPPER_CLASS : implements
    
    rectangle "DTO Components" <<component>> as DTO_COMP
    rectangle "UserDTO.java\nWorkoutDTO.java\nGoalDTO.java\nExerciseDTO.java" <<class>> as DTO_CLASS
    DTO_COMP -down-> DTO_CLASS : defines
    
    rectangle "Repository Components" <<component>> as REPO_COMP
    rectangle "UserRepository.java\nWorkoutRepository.java\nGoalRepository.java" <<class>> as REPO_CLASS
    REPO_COMP -down-> REPO_CLASS : implements
    
    rectangle "Entity Components" <<component>> as ENT_COMP
    rectangle "User.java (@Entity)\nWorkout.java (@Entity)\nGoal.java (@Entity)\nExercise.java (@Entity)" <<class>> as ENT_CLASS
    ENT_COMP -down-> ENT_CLASS : defines
}

note right of ENT_CLASS
  **Data-layer mapping**
  • DTOs live in fitness-backend/.../dto/.
  • Entities live in .../model/ and are annotated with @Entity/@Table.
  • Repositories extend JpaRepository<> (Spring Data).
  • Mappers convert DTOs↔Entities to keep services DTO-centric.
end note

' ==================== CONNECTORS ====================
note as CONNECTOR_NOTE
**CONNECTOR IMPLEMENTATIONS**

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**1. Frontend HTTP calls** (api.ts → Controllers)
   • Implemented with fetch in src/services/api.ts.
   • Uses JSON payloads and CORS (CorsConfig.java).
   • Example: `userApi.getById(id)` fetches `/api/users/${id}`.

**2. Controller → Service connector**
   • Constructor injection with final fields.
   • Example (UserController): `public UserController(UserService userService)`.
   • Ensures controllers never touch repositories directly.

**3. Service → Mapper connector**
   • Services inject mapper beans (e.g., GoalMapper) to transform DTOs.
   • Methods: toDTO(), toEntity(), toSimpleDTO().

**4. Service → Repository connector**
   • Services call repository interfaces for persistence.
   • Example: `goalRepository.findByUserIdAndStatus(...)`.

**5. Repository → Database connector**
   • Spring Data JPA + Hibernate auto-generate SQL statements.
   • Configured in application.properties (JDBC URL, dialect).

**6. Mapper ↔ DTO/Entity connector**
   • Manual conversions keep passwords and lazy relationships safe.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Patterns enforced: MVC, Service Layer, Repository, DTO, Mapper, Dependency Injection.

end note

@enduml

